### I solve hard problems fast. The domain is irrelevant.

Bitcoin protocol design, AI knowledge systems, real-time microservices, government civic tech, nonprofit operations — I don't pick a lane. I pick the problem, reason from first principles, and ship.

Six production systems. Different domains. Same methodology.

---

#### The Work

[**OrangeCat**](https://github.com/g-but/orangecat) — Rebuilding commerce on Bitcoin. Entity Registry SSOT drives 13 entity types from one config file. Lightning Network payments. Actor system unifies individual and organizational ownership. Row Level Security at database level. [orangecat.ch](https://orangecat.ch)

[**Solon**](https://github.com/g-but/solon) — Replacing trust with math. Treasury on-chain, votes cryptographically signed, decisions tracked against KPIs. Four governance pillars, four voting mechanisms, five transparency metrics. If it can't be verified, it doesn't count.

[**Botsmann**](https://github.com/g-but/botsmann) — Multi-LLM routing across Groq, OpenRouter, and local Ollama. Six domain-specialized AI professionals with scoped knowledge. RAG via pgvector, zero-cost client-side embeddings. Four-layer prompt injection defense. [botsmann.vercel.app](https://botsmann.vercel.app)

[**RevampIT**](https://github.com/g-but/revampit) — Technology redistribution for a Swiss nonprofit. Custom CMS, 165 table constants as SSOT, 312 tests across 24 suites. Built because Strapi was slower, heavier, and harder to control. [revamp-it.ch](https://revamp-it.ch)

[**SBB Lost & Found**](https://github.com/g-but/sbb-lost-found) — Real-time lost item recovery for Swiss railways. Microservice architecture, Redis pub/sub, Socket.io live notifications. Collapses the recovery window from 24 hours to 30 minutes.

[**Reparaturbonus Zürich**](https://github.com/g-but/reparaturbonus-zh) — Government repair bonus platform. Radius-based shop search, bonus code generation, graceful API degradation. Repair over replace.

---

#### How I Think

**First principles, not best practices.** What problem am I actually solving? What are the real constraints? What is the simplest solution that respects them? If the answer to "why?" is "because other projects do it" — stop. Convention is not a reason. Analogy is not an argument. Derive every decision from ground truths.

**One source of truth, no exceptions.** Every piece of data lives in exactly one place. Types derived from schemas, never defined separately. Config drives behavior. If adding a field requires touching 5 files, the architecture is wrong.

**Complexity must earn its place.** Every abstraction is a tax on every future change. Three similar lines of code is better than a premature abstraction. Build for the current problem, not hypothetical future requirements.

**Automate the mechanical, reserve humans for judgment.** Formatting, validation, deployment, testing — machines. Architecture, UX, business decisions — humans. Every manual step that could be automated is a reliability risk.

Start with [`.claude/rules/`](https://github.com/g-but/orangecat/tree/main/.claude/rules) in OrangeCat for 5,500 lines of architectural patterns, or the [test suites](https://github.com/g-but/revampit/tree/main/tests) in RevampIT.

---

#### The Thesis

Blockchain removes the need to trust institutions. AI removes the need for repetitive labor. Robotics removes the need for human drudgery. Together, they don't improve the current system — they make it obsolete.

We are entering the technological singularity. The result is a society of sustainable abundance. I build the infrastructure for that transition.

---

TypeScript, Next.js, React, PostgreSQL, Supabase, Prisma, Bitcoin/Lightning, Zod, Tailwind
