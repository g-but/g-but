### Give me a hard problem and a cup of tea.

Bitcoin, AI, real-time systems, government platforms, nonprofit ops. I go where the interesting problems are, figure them out from first principles, and ship. Life's too short for best practices that nobody can explain.

---

#### The Work

[**OrangeCat**](https://github.com/g-but/orangecat) — Rebuilding commerce on Bitcoin. One Entity Registry config file drives 13 entity types, all CRUD, navigation, and validation. Lightning Network payments, actor-based ownership model, RLS at the database level. [orangecat.ch](https://orangecat.ch)

[**Solon**](https://github.com/g-but/solon) — Governance where every treasury transaction is on-chain, every vote is cryptographically signed, and every decision is tracked against KPIs. If it can't be verified, it doesn't count.

[**Botsmann**](https://github.com/g-but/botsmann) — Routes queries across Groq, OpenRouter, and local Ollama. Six AI professionals with scoped knowledge bases. Client-side embeddings (zero API cost), pgvector search, four-layer prompt injection defense. [botsmann.vercel.app](https://botsmann.vercel.app)

[**RevampIT**](https://github.com/g-but/revampit) — Swiss nonprofit giving tech a second life. Custom CMS because Strapi was slower, heavier, and harder to control. 165 table constants as SSOT, 312 tests. [revamp-it.ch](https://revamp-it.ch)

[**SBB Lost & Found**](https://github.com/g-but/sbb-lost-found) — Real-time lost item recovery for Swiss railways. Redis pub/sub, Socket.io, microservices. Gets the recovery window from 24 hours down to 30 minutes.

[**Reparaturbonus Zürich**](https://github.com/g-but/reparaturbonus-zh) — City of Zurich repair bonus platform. Radius-based shop search, bonus code generation, APIs that degrade gracefully. Repair over replace.

---

#### How I Think

I start with the problem, not the tools. What are the actual constraints? What's the simplest thing that works within them? If the only reason to do something is "that's how other projects do it," it's not a reason.

Every piece of data gets one home. Types come from schemas. Config drives behavior. If adding a field means touching 5 files, the architecture needs fixing.

I don't build for hypothetical future requirements. Three lines of similar code beats a premature abstraction every time. Complexity has to justify itself.

Machines are better than humans at almost everything now. Architecture, UX, product decisions, code, testing. The only thing left that's uniquely human is deciding what's worth building in the first place. I do that part. My army of robots does the rest.

If you're the kind of person who reads architecture docs for fun, start with [`.claude/rules/`](https://github.com/g-but/orangecat/tree/main/.claude/rules) in OrangeCat. 5,500 lines. You're welcome.

---

#### Where this is going

Blockchain makes middlemen unnecessary. AI handles the boring work. Robotics handles the physical work. Stack all three and you get a world that runs on abundance instead of scarcity. We're closer to that than most people realize, and I'm building the infrastructure to get there.

When I'm not commanding robots, I'm probably listening to electronic music and thinking about the next problem worth solving.

---

TypeScript, Next.js, React, PostgreSQL, Supabase, Prisma, Bitcoin/Lightning, Zod, Tailwind
