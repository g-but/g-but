### I like hard problems. I don't care what domain they're in.

Bitcoin, AI, real-time systems, government platforms, nonprofit ops. I go where the interesting problems are, reason from first principles, and ship.

---

#### The Work

[**OrangeCat**](https://github.com/g-but/orangecat) — Rebuilding commerce on Bitcoin. One Entity Registry config file drives 13 entity types, all CRUD, navigation, and validation. Lightning Network payments, actor-based ownership model, RLS at the database level. [orangecat.ch](https://orangecat.ch)

[**Solon**](https://github.com/g-but/solon) — Governance where every treasury transaction is on-chain, every vote is cryptographically signed, and every decision is tracked against KPIs. If it can't be verified, it doesn't count.

[**Botsmann**](https://github.com/g-but/botsmann) — Routes queries across Groq, OpenRouter, and local Ollama. Six AI professionals with scoped knowledge bases. Client-side embeddings (zero API cost), pgvector search, four-layer prompt injection defense. [botsmann.vercel.app](https://botsmann.vercel.app)

[**RevampIT**](https://github.com/g-but/revampit) — Swiss nonprofit giving tech a second life. Custom CMS because Strapi was slower, heavier, and harder to control. 165 table constants as SSOT, 312 tests. [revamp-it.ch](https://revamp-it.ch)

[**SBB Lost & Found**](https://github.com/g-but/sbb-lost-found) — Real-time lost item recovery for Swiss railways. Redis pub/sub, Socket.io, microservices. Gets the recovery window from 24 hours down to 30 minutes.

[**Reparaturbonus Zürich**](https://github.com/g-but/reparaturbonus-zh) — City of Zurich repair bonus platform. Radius-based shop search, bonus code generation, APIs that degrade gracefully. Repair over replace.

---

#### How I Think

I start with the problem, not the tools. What are the actual constraints? What's the simplest thing that works within them? If the only reason to do something is "that's how other projects do it," it's not a reason.

Every piece of data gets one home. Types come from schemas. Config drives behavior. If adding a field means touching 5 files, the architecture needs fixing.

I don't build for hypothetical future requirements. Three lines of similar code beats a premature abstraction every time. Complexity has to justify itself.

Machines should do what machines are good at (formatting, validation, testing, deployment). Humans should do what humans are good at (architecture, UX, product decisions). Mixing these up is how you get both bad code and burnt-out engineers.

Dig into [`.claude/rules/`](https://github.com/g-but/orangecat/tree/main/.claude/rules) in OrangeCat for 5,500 lines of how this plays out in practice.

---

#### Where this is going

Blockchain makes middlemen unnecessary. AI handles the boring work. Robotics handles the physical work. Stack all three and you get a world that runs on abundance instead of scarcity. We're closer to that than most people realize, and I'm building the infrastructure to get there.

---

TypeScript, Next.js, React, PostgreSQL, Supabase, Prisma, Bitcoin/Lightning, Zod, Tailwind
